<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=��evice-width, initial-scale=1.0">
    <meta name="google-site-verification" content="6WAYw55ioji2erHb-5NbNj-1UUxXejHX_e_PDEOf1Wg" />
    <meta name="google-adsense-account" content="ca-pub-7255009353291623">
    <title>NFL Stats</title>
    <link rel="icon" type="image/png" href="https://raw.githubusercontent.com/killenden/NFL_stats/main/docs/images/jared_goff.png">
    <link rel="stylesheet" href="styles.css">
    <script src="theme-toggle.js" defer></script>
</head>
<body>
    <div class="hero-section">
        <div class="hero-text">
            <h1>Sleeper Integration</h1>
            <p>Review your Sleeper leagues</p>
        </div>
    </div>
    
    <nav>
        <a href="index.html">Home</a>
        <a href="player.html">Player</a> 
        <a href="team.html">Team</a>
        <a href="weather.html">Weather</a>
        <a href="sleeper.html" class="active">Sleeper</a>
        <a href="about.html">About</a>
    </nav>
    <div class="container">
        <h2>Get Sleeper League Info</h2>
        <div class="input-section">
            <label for="input">Enter Sleeper Username or League ID:</label>
            <input type="text" id="input" placeholder="e.g., username or 123456789012345678">
            <button onclick="getUserOrLeague()">Get League Info</button>
        </div>
    <div id="league-info"></div>
    <div id="blocks"></div>
        
    </div>

    <script>
        async function getUserOrLeague() {
            const input = document.getElementById('input').value;
            const leagueInfoDiv = document.getElementById('league-info');

            if (!input) {
                leagueInfoDiv.innerHTML = '<p>Please enter a username or league ID.</p>';
                return;
            }

            leagueInfoDiv.innerHTML = '<p class="loading">Loading info...</p>';

            if (isNaN(input)) {
                // Input is a username
                try {
                    // Fetch user information using input
                    const inputResponse = await fetch(`https://api.sleeper.app/v1/user/${input}`);
                    if (!inputResponse.ok) {
                        throw new Error('User not found');
                    }

                    const inputData = await inputResponse.json(); // Parse response as JSON
                    const userId = inputData.user_id;

                    // Fetch leagues for the user
                    const leaguesResponse = await fetch(`https://api.sleeper.app/v1/user/${userId}/leagues/nfl/2025`);
                    if (!leaguesResponse.ok) {
                        throw new Error('No leagues found for this user');
                    }

                    const leaguesData = await leaguesResponse.json(); // Parse leagues data

                    /// Check if leagues were found and generate HTML
                    if (leaguesData.length > 0) {
                        let leagueList = '<h3>Select a League:</h3><ul>';
                        leaguesData.forEach(league => {
                            leagueList += `
                                <li>
                                    <button onclick="selectLeague('${league.league_id}', '${league.name}')">${league.name}</button>
                                </li>
                            `;
                        });
                        leagueList += '</ul>';
                        leagueInfoDiv.innerHTML = leagueList;
                    } else {
                        leagueInfoDiv.innerHTML = '<p>No leagues found for this user.</p>';
                    }
                } catch (error) {
                    leagueInfoDiv.innerHTML = `<p>Error: ${error.message}</p>`;
                    console.error('Error:', error);
                }
            } else {
                // Input is a league ID
                getLeague(input);
            }
        }

        let _lastLeagueId = null;
        let _lastLeagueData = null;

        async function getLeague(leagueId, maxWeeks = 18) {
            _lastLeagueId = leagueId;
            const leagueInfoDiv = document.getElementById('league-info');
            leagueInfoDiv.innerHTML = '<p class="loading">Loading league info...</p>';

            try {
                const leagueResponse = await fetch(`https://api.sleeper.app/v1/league/${leagueId}`);
                if (!leagueResponse.ok) throw new Error('League not found');
                const leagueData = await leagueResponse.json();

                _lastLeagueData = leagueData;

                leagueInfoDiv.innerHTML = `
                    <h3>League Info:</h3>
                    <p>League Name: ${escapeHTML(leagueData.name)}</p>
                    <p>League ID: ${escapeHTML(leagueData.league_id)}</p>
                    <p>Season: ${escapeHTML(leagueData.season)}</p>
                `;

                // Clear existing blocks and controls for a fresh league view
                const blocksDiv = document.getElementById('blocks');
                if (blocksDiv) blocksDiv.innerHTML = '';

                // Create block controls (toggles) area
                let controls = document.getElementById('block-controls');
                if (!controls) {
                    controls = document.createElement('div');
                    controls.id = 'block-controls';
                    controls.className = 'block-controls';
                    leagueInfoDiv.parentNode.insertBefore(controls, document.getElementById('blocks'));
                } else {
                    controls.innerHTML = '';
                }

                // Create Luck toggle button
                const luckToggle = document.createElement('button');
                luckToggle.className = 'block-toggle';
                luckToggle.innerText = '🔮 Luck';
                luckToggle.onclick = () => {
                    const willBeActive = !luckToggle.classList.contains('active');
                    // deactivate other toggles
                    Array.from(controls.querySelectorAll('.block-toggle')).forEach(btn => {
                        if (btn !== luckToggle) {
                            btn.classList.remove('active');
                        }
                    });
                    // remove other blocks
                    removePowerBlock();

                    if (willBeActive) {
                        luckToggle.classList.add('active');
                        renderLuckBlock();
                    } else {
                        luckToggle.classList.remove('active');
                        removeLuckBlock();
                    }
                };
                controls.appendChild(luckToggle);
                // Create Power Rankings toggle button
                const powerToggle = document.createElement('button');
                powerToggle.className = 'block-toggle';
                powerToggle.innerText = '📊 Power Rankings';
                powerToggle.onclick = () => {
                    const willBeActive = !powerToggle.classList.contains('active');
                    // deactivate other toggles
                    Array.from(controls.querySelectorAll('.block-toggle')).forEach(btn => {
                        if (btn !== powerToggle) {
                            btn.classList.remove('active');
                        }
                    });
                    // remove other blocks
                    removeLuckBlock();

                    if (willBeActive) {
                        powerToggle.classList.add('active');
                        renderPowerBlock();
                    } else {
                        powerToggle.classList.remove('active');
                        removePowerBlock();
                    }
                };
                controls.appendChild(powerToggle);
                // Create Strength of Schedule toggle button
                const sosToggle = document.createElement('button');
                sosToggle.className = 'block-toggle';
                sosToggle.innerText = '🛡️ Strength of Schedule';
                sosToggle.onclick = () => {
                    const willBeActive = !sosToggle.classList.contains('active');
                    // deactivate other toggles
                    Array.from(controls.querySelectorAll('.block-toggle')).forEach(btn => {
                        if (btn !== sosToggle) {
                            btn.classList.remove('active');
                        }
                    });
                    // remove other blocks
                    removeLuckBlock();
                    removePowerBlock();

                    if (willBeActive) {
                        sosToggle.classList.add('active');
                        renderSoSBlock();
                    } else {
                        sosToggle.classList.remove('active');
                        removeSoSBlock();
                    }
                };
                controls.appendChild(sosToggle);

                const [rostersResponse, usersResponse] = await Promise.all([
                    fetch(`https://api.sleeper.app/v1/league/${leagueId}/rosters`),
                    fetch(`https://api.sleeper.app/v1/league/${leagueId}/users`),
                ]);

                if (!rostersResponse.ok) throw new Error('No rosters found');
                if (!usersResponse.ok) throw new Error('No users found');

                const [rostersData, usersData] = await Promise.all([
                    rostersResponse.json(),
                    usersResponse.json(),
                ]);

                const userMap = {};
                usersData.forEach(user => {
                    userMap[user.user_id] = user.display_name;
                });

                if (rostersData.length > 0) {
                    // We'll compute expected wins (luck) by fetching matchups for the season
                    const rosterIds = rostersData.map(r => r.roster_id);
                    const rosterIndex = {};
                    rostersData.forEach((r, i) => { rosterIndex[r.roster_id] = i; });

                    // Track processed win/loss/tie record based only on the matchups we've fetched
                    const processedRecord = {};
                    rostersData.forEach(r => { processedRecord[r.roster_id] = { wins: 0, losses: 0, ties: 0 }; });

                    // Determine last completed week from NFL state and ignore the current active week
                    let lastCompletedWeek = maxWeeks;
                    try {
                        const stateResp = await fetch('https://api.sleeper.app/v1/state/nfl');
                        if (stateResp.ok) {
                            const stateData = await stateResp.json();
                            const currentWeek = Number(stateData.week || 0);
                            if (currentWeek > 0) {
                                // ignore the current active week entirely
                                lastCompletedWeek = Math.max(0, currentWeek - 1);
                            }
                        }
                    } catch (e) {
                        console.warn('debug: unable to fetch NFL state, defaulting to maxWeeks', e);
                    }
                    // clamp to provided maxWeeks
                    lastCompletedWeek = Math.min(lastCompletedWeek, maxWeeks);

                    // Initialize stats per roster
                    const stats = rostersData.map(r => ({
                        roster_id: r.roster_id,
                        owner: escapeHTML(userMap[r.owner_id] || 'Unknown'),
                        wins: r.settings.wins ?? 0,
                        ties: r.settings.ties ?? 0,
                        losses: r.settings.losses ?? 0,
                        points: r.settings.fpts ?? 0,
                        expectedWins: 0, // games outscored opponents
                        // gamesCounted should reflect the roster's recorded games: wins + losses + ties
                        gamesCounted: (r.settings.wins ?? 0) + (r.settings.losses ?? 0) + (r.settings.ties ?? 0),
                        luckyWins: 0,
                        unluckyLosses: 0,
                        opponents: [], // list of opponent roster_ids (one entry per matchup opponent)
                        pointsAgainst: 0 // sum of opponents' points across matchups
                    }));

                    // Fetch matchups for season weeks. Try weeks 1-18; stop when no data returned for the week.
                    const season = leagueData.season || '2025';
                    for (let week = 1; week <= lastCompletedWeek; week++) {
                        try {
                            const mResp = await fetch(`https://api.sleeper.app/v1/league/${leagueId}/matchups/${week}`);
                            if (!mResp.ok) break; // no more matchup data
                            const matchups = await mResp.json();
                            console.log('debug: week', week, 'matchups sample', Array.isArray(matchups) ? matchups.slice(0,3) : matchups);
                            if (!Array.isArray(matchups) || matchups.length === 0) break;

                            // Compute median points across all rosters this week for lucky/unlucky classification
                            const allPoints = matchups.map(e => Number(e.points ?? e.fpts ?? 0)).filter(v => !isNaN(v));
                            let medianPoint = 0;
                            if (allPoints.length > 0) {
                                allPoints.sort((a, b) => a - b);
                                const mid = Math.floor(allPoints.length / 2);
                                medianPoint = (allPoints.length % 2 === 1) ? allPoints[mid] : ((allPoints[mid - 1] + allPoints[mid]) / 2);
                            }

                            // For each matchup, compare points and award expected win to higher score
                            matchups.forEach(mu => {
                                if (!mu || typeof mu.roster_id === 'undefined') return;
                                // Sleeper returns an array of matchup objects where each has roster_id and points
                                // But depending on endpoint, matchups may be an array of rosters for that week.
                                // We'll handle arrays of roster objects (common) where each element has "roster_id" and "points".
                                if (Array.isArray(mu)) return; // defensive: skip nested arrays
                            });

                            // The /matchups/{week} endpoint returns an array of roster objects (each roster entry for that week),
                            // but the pairing isn't explicit here. We'll instead use /league/{leagueId}/matchups/{week} which returns
                            // an array of matchup objects; ensure we treat each object that contains multiple roster entries.
                            // To be robust, if matchups is an array of objects where each object has a "players" or "rosters" field,
                            // attempt to normalize. Otherwise, if entries have "roster_id" and "points", group by matchupId.

                            // Build grouping: if objects have 'matchup_id' or 'matchup_id' use that, otherwise try 'matchup' or pair by order.
                            const groups = {};
                            matchups.forEach(entry => {
                                const mid = entry.matchup_id ?? entry.matchup ?? entry.week ?? entry.matchupId ?? 'm_' + (entry.roster_id ?? Math.random());
                                if (!groups[mid]) groups[mid] = [];
                                groups[mid].push(entry);
                            });

                            Object.entries(groups).forEach(([mid, group]) => {
                                if (group.length < 2) return; // need opponent to compare
                                // Log group structure for debugging
                                console.log('debug: week', week, 'group', mid, group.map(g => ({ rid: g.roster_id, pts: Number(g.points ?? g.fpts ?? null) })));
                                // Determine max points in group to detect ties
                                const ptsArr = group.map(e => Number(e.points ?? e.fpts ?? 0));
                                const maxPts = Math.max(...ptsArr);
                                const winners = group.filter(e => Number(e.points ?? e.fpts ?? 0) === maxPts);
                                const isTie = winners.length > 1;
                                console.log('debug: week', week, 'mid', mid, 'ptsArr', ptsArr, 'maxPts', maxPts, 'winners', winners.map(w => w.roster_id), 'isTie', isTie);

                                // For each roster in group, compare to opponents
                                group.forEach(playerEntry => {
                                    const rid = playerEntry.roster_id;
                                    const pts = Number(playerEntry.points ?? playerEntry.fpts ?? 0);
                                    if (rid == null) return;
                                    const idx = rosterIndex[rid];
                                    if (typeof idx === 'undefined') return; // roster not in this league's roster list
                                    // record opponents faced this week (one entry per opponent)
                                    group.forEach(otherOpp => {
                                        if (!otherOpp || otherOpp.roster_id == null) return;
                                        if (otherOpp.roster_id !== rid) {
                                            stats[idx].opponents.push(otherOpp.roster_id);
                                            // accumulate pointsAgainst by summing opponent points for this matchup
                                            const otherPts = Number(otherOpp.points ?? otherOpp.fpts ?? 0) || 0;
                                            stats[idx].pointsAgainst = (stats[idx].pointsAgainst || 0) + otherPts;
                                        }
                                    });
                                    // Compare against other players in same group to compute expectedWins
                                    let winsAgainst = 0;
                                    group.forEach(other => {
                                        if (other === playerEntry) return;
                                        const otherPts = Number(other.points ?? other.fpts ?? 0);
                                        if (pts > otherPts) winsAgainst += 1;
                                    });
                                    const fractional = winsAgainst / (group.length - 1);
                                    stats[idx].expectedWins += fractional;

                                    // Determine whether this roster "won", "lost", or tied the matchup using maxPts
                                    let won = false;
                                    let lost = false;
                                    let tied = false;
                                    if (isTie) {
                                        // if there are multiple winners, any roster with pts === maxPts is tied for win
                                        if (pts === maxPts) tied = true; else lost = true;
                                    } else {
                                        if (pts === maxPts) won = true; else lost = true;
                                    }

                                    // Log player result before updating processedRecord
                                    console.log('debug: player', rid, 'pts', pts, { won, tied, lost });
                                    // Update processed record only for games we've fetched
                                    if (processedRecord[rid]) {
                                        if (won) processedRecord[rid].wins += 1;
                                        else if (lost) processedRecord[rid].losses += 1;
                                        else if (tied) processedRecord[rid].ties += 1;
                                        console.log('debug: processedRecord update for', rid, processedRecord[rid]);
                                    }

                                    if (won && pts < medianPoint) {
                                        stats[idx].luckyWins += 1;
                                    }
                                    if (lost && pts > medianPoint) {
                                        stats[idx].unluckyLosses += 1;
                                    }
                                });
                            });
                        } catch (e) {
                            console.warn('Week fetch error', week, e);
                            break;
                        }
                    }

                    // Now compute luck = (+1 per lucky win) + (-1 per unlucky loss)
                    stats.forEach(s => {
                        s.luck = (s.luckyWins ?? 0) - (s.unluckyLosses ?? 0);
                    });

                    // Prepare summary: top 3 lucky and top 3 unlucky
                    const summary = [...stats];
                    summary.sort((a, b) => b.luck - a.luck);
                    const topLucky = summary.slice(0, 3);
                    const topUnlucky = summary.slice(-3).reverse();

                    // Build luck block content
                    let summaryHTML = `<div class="stats-highlight center"><h4>Luck Summary</h4><div style="display:flex;gap:20px;flex-wrap:wrap;">`;
                    summaryHTML += `<div><strong>Top Lucky</strong><ol>`;
                    topLucky.forEach(t => { summaryHTML += `<li>${t.owner} (${t.luck>=0? '+'+t.luck: t.luck})</li>` });
                    summaryHTML += `</ol></div>`;
                    summaryHTML += `<div><strong>Top Unlucky</strong><ol>`;
                    topUnlucky.forEach(t => { summaryHTML += `<li>${t.owner} (${t.luck>=0? '+'+t.luck: t.luck})</li>` });
                    summaryHTML += `</ol></div>`;
                    summaryHTML += `</div></div>`;

                    // Generate table HTML (no change to content)

                    // Sort standings by wins descending
                    stats.sort((a, b) => b.wins - a.wins || b.points - a.points);

                    // Generate standings table with Expected Wins and Luck columns
                    let tableHTML = `
                        <h3>Standings (with Luck):</h3>
                        <table border="1">
                            <thead>
                                <tr>
                                    <th onclick="sortTable(0)">Owner</th>
                                    <th onclick="sortTable(1)">Wins</th>
                                    <th onclick="sortTable(2)">Losses</th>
                                    <th onclick="sortTable(3)">Points</th>
                            <th onclick="sortTable(4,this)">Luck</th>
                            <th onclick="sortTable(5,this)">Lucky Wins</th>
                            <th onclick="sortTable(6,this)">Unlucky Losses</th>
                                </tr>
                            </thead>
                            <tbody>
                    `;

                    stats.forEach(s => {
                        const wins = s.wins ?? 0;
                        const losses = s.losses ?? 0;
                        const points = s.points ?? 0;
                        const luck = Number(s.luck ?? 0);
                        const luckyWins = s.luckyWins ?? 0;
                        const unluckyLosses = s.unluckyLosses ?? 0;
                        tableHTML += `
                            <tr>
                                <td>${s.owner}</td>
                                <td>${wins}</td>
                                <td>${losses}</td>
                                <td>${points}</td>
                                <td style="color:${luck>0? 'green': (luck<0? 'red':'black')}">${luck>0? '+'+luck: luck}</td>
                                <td>${luckyWins}</td>
                                <td>${unluckyLosses}</td>
                            </tr>
                        `;
                    });

                    tableHTML += `</tbody></table>`;

                    // Prepare content for luck block but do not render immediately — provide a renderer
                    window.__luckBlockContent = { summaryHTML, tableHTML };
                    function renderLuckBlock() {
                        const blocksDiv = document.getElementById('blocks');
                        const luckBlock = document.createElement('div');
                        luckBlock.className = 'block';
                        luckBlock.id = 'luck-block';
                        luckBlock.innerHTML = `<h3>Luck</h3>` + window.__luckBlockContent.summaryHTML + window.__luckBlockContent.tableHTML;
                        const existing = document.getElementById('luck-block');
                        if (existing) blocksDiv.replaceChild(luckBlock, existing); else blocksDiv.appendChild(luckBlock);
                    }
                    function removeLuckBlock() {
                        const existing = document.getElementById('luck-block');
                        if (existing) existing.remove();
                    }

                    // --- Power Rankings content: compute PPG and ranks ---
                    // Compute PPG based on recorded matchup games (gamesCounted) when available.
                    // This is more reliable than relying on settings.wins/settings.losses which
                    // may be missing or not reflect number of games fetched.
                    const power = stats.map(s => {
                        const wins = s.wins ?? 0;
                        const losses = s.losses ?? 0;
                        const ties = s.ties ?? 0;
                        // Use processedRecord (only completed/fetched weeks) to compute matches when available
                        const rec = processedRecord[s.roster_id] || { wins: 0, losses: 0, ties: 0 };
                        const matchesFromRecord = Number(rec.wins || 0) + Number(rec.losses || 0) + Number(rec.ties || 0);
                        const matchesFallback = Number(wins) + Number(losses) + Number(ties || 0);
                        const matches = (matchesFromRecord > 0) ? matchesFromRecord : matchesFallback;
                        return {
                            roster_id: s.roster_id,
                            owner: s.owner,
                            points: s.points ?? 0,
                            matches: matches,
                            wins: wins,
                            losses: losses,
                            ppg: (matches > 0) ? (s.points / matches) : 0
                        };
                    });
                    power.sort((a, b) => b.ppg - a.ppg || b.points - a.points);
                    // assign rank after sorting: 1 = highest PPG
                    power.forEach((p, i) => { p.rank = i + 1; });
                    let powerSummary = `<div class="stats-highlight"><h4>Power Rankings Top</h4><ol>`;
                    power.slice(0,3).forEach(p => { powerSummary += `<li>${p.owner} — ${p.ppg.toFixed(1)} PPG</li>`; });
                    powerSummary += `</ol></div>`;

                    let powerTable = `
                        <h3>Power Rankings (by PPG)</h3>
                        <table border="1">
                            <thead>
                                <tr>
                                    <th onclick="sortTable(0,this)">Rank</th>
                                    <th onclick="sortTable(1,this)">Owner</th>
                                    <th onclick="sortTable(2,this)">PPG</th>
                                    <th onclick="sortTable(3,this)">Total Points</th>
                                    <th onclick="sortTable(4,this)">Matches</th>
                                    <th onclick="sortTable(5,this)">Wins</th>
                                    <th onclick="sortTable(6,this)">Losses</th>
                                </tr>
                            </thead>
                            <tbody>
                    `;
                    power.forEach(p => {
                        powerTable += `
                            <tr>
                                <td>${p.rank}</td>
                                <td>${p.owner}</td>
                                <td>${p.ppg.toFixed(1)}</td>
                                <td>${p.points}</td>
                                <td>${p.matches}</td>
                                <td>${p.wins}</td>
                                <td>${p.losses}</td>
                            </tr>
                        `;
                    });
                    powerTable += `</tbody></table>`;

                    window.__powerBlockContent = { powerSummary, powerTable };
                    function renderPowerBlock() {
                        const blocksDiv = document.getElementById('blocks');
                        const powerBlock = document.createElement('div');
                        powerBlock.className = 'block';
                        powerBlock.id = 'power-block';
                        powerBlock.innerHTML = `<h3>Power Rankings</h3>` + window.__powerBlockContent.powerSummary + window.__powerBlockContent.powerTable;
                        const existing = document.getElementById('power-block');
                        if (existing) blocksDiv.replaceChild(powerBlock, existing); else blocksDiv.appendChild(powerBlock);
                    }
                    function removePowerBlock() {
                        const existing = document.getElementById('power-block');
                        if (existing) existing.remove();
                    }

                    // --- Strength of Schedule (SoS) computation ---
                    // Map roster_id -> ppg for opponent lookup
                    const rosterPPG = {};
                    power.forEach(p => { rosterPPG[p.roster_id] = p.ppg; });

                    // Compute SoS and opponents record using processed matchups only
                    stats.forEach(s => {
                        const opps = s.opponents || [];
                        // Deduplicate opponents for combined record calculation (count each opponent once)
                        const uniqueOpps = Array.from(new Set(opps));

                        // Compute matches (number of weeks/games the team has played) using gamesCounted or fallback
                        const matchesFromRecord = Number(s.gamesCounted || 0);
                        const matchesFallback = Number(s.wins || 0) + Number(s.losses || 0);
                        const matches = (matchesFromRecord > 0) ? matchesFromRecord : matchesFallback;

                        // SoS = pointsAgainst divided by number of games the team has played
                        const ptsAgainst = Number(s.pointsAgainst || 0);
                        s.sos = (matches > 0) ? (ptsAgainst / matches) : 0;

                        // Combined opponents record (sum wins/losses/ties of unique opponents) based on processedRecord
                        let oppWins = 0;
                        let oppLosses = 0;
                        let oppTies = 0;
                        uniqueOpps.forEach(rid => {
                            const rec = processedRecord[rid];
                            if (rec) {
                                oppWins += rec.wins || 0;
                                oppLosses += rec.losses || 0;
                                oppTies += rec.ties || 0;
                            }
                        });
                        s.opponentsCombinedRecord = oppTies ? `${oppWins}-${oppLosses}-${oppTies}` : `${oppWins}-${oppLosses}`;
                    });

                    // Expose debug state for inspection in DevTools
                    window.__lastStats = stats;
                    window.__processedRecord = processedRecord;
                    console.log('debug: FINAL stats snapshot', stats);
                    console.log('debug: FINAL processedRecord', processedRecord);

                    // Prepare SoS summary: hardest (highest opponent PPG) and easiest
                    const sosSorted = [...stats].sort((a,b) => b.sos - a.sos);
                    const topHard = sosSorted.slice(0,3);
                    const topEasy = sosSorted.slice(-3).reverse();

                    let sosSummary = `<div class="stats-highlight"><h4>Strength of Schedule Top</h4><div style="display:flex;gap:20px;flex-wrap:wrap;">`;
                    sosSummary += `<div><strong>Hardest Schedules</strong><ol>`;
                    topHard.forEach(t => { sosSummary += `<li>${t.owner} — Opp Avg PPG: ${t.sos.toFixed(1)}</li>`; });
                    sosSummary += `</ol></div>`;
                    sosSummary += `<div><strong>Easiest Schedules</strong><ol>`;
                    topEasy.forEach(t => { sosSummary += `<li>${t.owner} — Opp Avg PPG: ${t.sos.toFixed(1)}</li>`; });
                    sosSummary += `</ol></div></div></div>`;

                    let sosTable = `
                        <h3>Strength of Schedule</h3>
                        <table border="1">
                            <thead>
                                <tr>
                                            <th>Owner</th>
                                                <th>Opp Avg PPG (SoS)</th>
                                                <th>Opponents Record</th>
                                </tr>
                            </thead>
                            <tbody>
                    `;
                    // sort by sos desc for table
                    const sosForTable = [...stats].sort((a,b) => b.sos - a.sos);
                    sosForTable.forEach(s => {
                        sosTable += `
                            <tr>
                                <td>${s.owner}</td>
                                            <td>${s.sos.toFixed(2)}</td>
                                            <td>${s.opponentsCombinedRecord || '0-0'}</td>
                            </tr>
                        `;
                    });
                    sosTable += `</tbody></table>`;

                    window.__sosBlockContent = { sosSummary, sosTable };
                    function renderSoSBlock() {
                        const blocksDiv = document.getElementById('blocks');
                        const sosBlock = document.createElement('div');
                        sosBlock.className = 'block';
                        sosBlock.id = 'sos-block';
                        sosBlock.innerHTML = window.__sosBlockContent.sosSummary + window.__sosBlockContent.sosTable;
                        const existing = document.getElementById('sos-block');
                        if (existing) blocksDiv.replaceChild(sosBlock, existing); else blocksDiv.appendChild(sosBlock);
                    }
                    function removeSoSBlock() {
                        const existing = document.getElementById('sos-block');
                        if (existing) existing.remove();
                    }
                } else {
                    leagueInfoDiv.innerHTML += '<p>No rosters found for this league.</p>';
                }
            } catch (error) {
                leagueInfoDiv.innerHTML = `<p>Error: ${error.message}</p>`;
                console.error('Error:', error);
            }
        }

        // Add sorting functionality
        function sortTable(columnIndex, headerEl) {
            // Determine target table body: if headerEl provided, use its table; otherwise fallback
            let tbody;
            if (headerEl && headerEl.closest) {
                const tableEl = headerEl.closest('table');
                if (tableEl) tbody = tableEl.querySelector('tbody');
            }
            if (!tbody) tbody = document.querySelector('#league-info table tbody');
            if (!tbody) return;

            const rows = Array.from(tbody.rows);
            if (rows.length < 2) return; // nothing to sort

            // Determine sort direction based on first two rows (text comparison)
            const aText = rows[0].cells[columnIndex]?.innerText ?? '';
            const bText = rows[1].cells[columnIndex]?.innerText ?? '';
            const ascending = aText > bText;

            // Sort rows using numeric-aware localeCompare
            rows.sort((a, b) => {
                const cellA = a.cells[columnIndex]?.innerText ?? '';
                const cellB = b.cells[columnIndex]?.innerText ?? '';
                return ascending
                    ? cellA.localeCompare(cellB, undefined, { numeric: true })
                    : cellB.localeCompare(cellA, undefined, { numeric: true });
            });

            // Rebuild table body
            tbody.innerHTML = '';
            rows.forEach(row => tbody.appendChild(row));
        }


        // Function to handle league selection
        function selectLeague(leagueId, leagueName) {
            console.log(`Selected League ID: ${leagueId}, Name: ${leagueName}`);
            // Additional logic for the selected league can go here
            getLeague(leagueId)
        }
        function escapeHTML(str) {
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }
    </script>
    
    <div class="copyright">
        <p>Copyright © 2025 Kyle Illenden, Anthony Illenden. Released under MIT License.</p>
        <p>LaPorta Potty Platoon</p>
    </div>
</body>
</html>

