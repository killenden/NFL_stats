<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=ï¿½ï¿½evice-width, initial-scale=1.0">
    <meta name="google-site-verification" content="6WAYw55ioji2erHb-5NbNj-1UUxXejHX_e_PDEOf1Wg" />
    <meta name="google-adsense-account" content="ca-pub-7255009353291623">
    <title>NFL Stats</title>
    <link rel="icon" type="image/png" href="https://raw.githubusercontent.com/killenden/NFL_stats/main/docs/images/jared_goff.png">
    <link rel="stylesheet" href="styles.css">
    <script src="theme-toggle.js" defer></script>
</head>
<body>
    <div class="hero-section">
        <div class="hero-text">
            <h1>Sleeper Integration</h1>
            <p>Review your Sleeper leagues</p>
        </div>
    </div>
    
    <nav>
        <a href="index.html">Home</a>
        <a href="player.html">Player</a> 
        <a href="team.html">Team</a>
        <a href="weather.html">Weather</a>
        <a href="sleeper.html" class="active">Sleeper</a>
        <a href="about.html">About</a>
    </nav>
    <div class="container">
        <h2>Get Sleeper League Info</h2>
        <div class="input-section">
            <label for="input">Enter Sleeper Username or League ID:</label>
            <input type="text" id="input" placeholder="e.g., username or 123456789012345678">
            <button onclick="getUserOrLeague()">Get League Info</button>
        </div>
    <div id="league-info"></div>
    <div id="blocks"></div>
        
    </div>

    <script>
        async function getUserOrLeague() {
            const input = document.getElementById('input').value;
            const leagueInfoDiv = document.getElementById('league-info');

            if (!input) {
                leagueInfoDiv.innerHTML = '<p>Please enter a username or league ID.</p>';
                return;
            }

            leagueInfoDiv.innerHTML = '<p class="loading">Loading info...</p>';

            if (isNaN(input)) {
                // Input is a username
                try {
                    // Fetch user information using input
                    const inputResponse = await fetch(`https://api.sleeper.app/v1/user/${input}`);
                    if (!inputResponse.ok) {
                        throw new Error('User not found');
                    }

                    const inputData = await inputResponse.json(); // Parse response as JSON
                    const userId = inputData.user_id;

                    // Fetch leagues for the user
                    const leaguesResponse = await fetch(`https://api.sleeper.app/v1/user/${userId}/leagues/nfl/2025`);
                    if (!leaguesResponse.ok) {
                        throw new Error('No leagues found for this user');
                    }

                    const leaguesData = await leaguesResponse.json(); // Parse leagues data

                    /// Check if leagues were found and generate HTML
                    if (leaguesData.length > 0) {
                        let leagueList = '<h3>Select a League:</h3><ul>';
                        leaguesData.forEach(league => {
                            leagueList += `
                                <li>
                                    <button onclick="selectLeague('${league.league_id}', '${league.name}')">${league.name}</button>
                                </li>
                            `;
                        });
                        leagueList += '</ul>';
                        leagueInfoDiv.innerHTML = leagueList;
                    } else {
                        leagueInfoDiv.innerHTML = '<p>No leagues found for this user.</p>';
                    }
                } catch (error) {
                    leagueInfoDiv.innerHTML = `<p>Error: ${error.message}</p>`;
                    console.error('Error:', error);
                }
            } else {
                // Input is a league ID
                getLeague(input);
            }
        }

        let _lastLeagueId = null;
        let _lastLeagueData = null;

        async function getLeague(leagueId, maxWeeks = 18) {
            _lastLeagueId = leagueId;
            const leagueInfoDiv = document.getElementById('league-info');
            leagueInfoDiv.innerHTML = '<p class="loading">Loading league info...</p>';

            try {
                const leagueResponse = await fetch(`https://api.sleeper.app/v1/league/${leagueId}`);
                if (!leagueResponse.ok) throw new Error('League not found');
                const leagueData = await leagueResponse.json();

                _lastLeagueData = leagueData;

                leagueInfoDiv.innerHTML = `
                    <h3>League Info:</h3>
                    <p>League Name: ${escapeHTML(leagueData.name)}</p>
                    <p>League ID: ${escapeHTML(leagueData.league_id)}</p>
                    <p>Season: ${escapeHTML(leagueData.season)}</p>
                `;

                // Clear existing blocks and controls for a fresh league view
                const blocksDiv = document.getElementById('blocks');
                if (blocksDiv) blocksDiv.innerHTML = '';

                // Create block controls (toggles) area
                let controls = document.getElementById('block-controls');
                if (!controls) {
                    controls = document.createElement('div');
                    controls.id = 'block-controls';
                    controls.className = 'block-controls';
                    leagueInfoDiv.parentNode.insertBefore(controls, document.getElementById('blocks'));
                } else {
                    controls.innerHTML = '';
                }

                // Create Luck toggle button
                const luckToggle = document.createElement('button');
                luckToggle.className = 'block-toggle';
                luckToggle.innerText = 'ðŸ”® Luck';
                luckToggle.onclick = () => {
                    const willBeActive = !luckToggle.classList.contains('active');
                    // deactivate other toggles
                    Array.from(controls.querySelectorAll('.block-toggle')).forEach(btn => {
                        if (btn !== luckToggle) {
                            btn.classList.remove('active');
                        }
                    });
                    // remove other blocks
                    removePowerBlock();

                    if (willBeActive) {
                        luckToggle.classList.add('active');
                        renderLuckBlock();
                    } else {
                        luckToggle.classList.remove('active');
                        removeLuckBlock();
                    }
                };
                controls.appendChild(luckToggle);
                // Create Power Rankings toggle button
                const powerToggle = document.createElement('button');
                powerToggle.className = 'block-toggle';
                powerToggle.innerText = 'ðŸ“Š Power Rankings';
                powerToggle.onclick = () => {
                    const willBeActive = !powerToggle.classList.contains('active');
                    // deactivate other toggles
                    Array.from(controls.querySelectorAll('.block-toggle')).forEach(btn => {
                        if (btn !== powerToggle) {
                            btn.classList.remove('active');
                        }
                    });
                    // remove other blocks
                    removeLuckBlock();

                    if (willBeActive) {
                        powerToggle.classList.add('active');
                        renderPowerBlock();
                    } else {
                        powerToggle.classList.remove('active');
                        removePowerBlock();
                    }
                };
                controls.appendChild(powerToggle);

                const [rostersResponse, usersResponse] = await Promise.all([
                    fetch(`https://api.sleeper.app/v1/league/${leagueId}/rosters`),
                    fetch(`https://api.sleeper.app/v1/league/${leagueId}/users`),
                ]);

                if (!rostersResponse.ok) throw new Error('No rosters found');
                if (!usersResponse.ok) throw new Error('No users found');

                const [rostersData, usersData] = await Promise.all([
                    rostersResponse.json(),
                    usersResponse.json(),
                ]);

                const userMap = {};
                usersData.forEach(user => {
                    userMap[user.user_id] = user.display_name;
                });

                if (rostersData.length > 0) {
                    // We'll compute expected wins (luck) by fetching matchups for the season
                    const rosterIds = rostersData.map(r => r.roster_id);
                    const rosterIndex = {};
                    rostersData.forEach((r, i) => { rosterIndex[r.roster_id] = i; });

                    // Initialize stats per roster
                    const stats = rostersData.map(r => ({
                        roster_id: r.roster_id,
                        owner: escapeHTML(userMap[r.owner_id] || 'Unknown'),
                        wins: r.settings.wins ?? 0,
                        losses: r.settings.losses ?? 0,
                        points: r.settings.fpts ?? 0,
                        expectedWins: 0, // games outscored opponents
                        gamesCounted: 0,
                        luckyWins: 0,
                        unluckyLosses: 0
                    }));

                    // Fetch matchups for season weeks. Try weeks 1-18; stop when no data returned for the week.
                    const season = leagueData.season || '2025';
                    for (let week = 1; week <= maxWeeks; week++) {
                        try {
                            const mResp = await fetch(`https://api.sleeper.app/v1/league/${leagueId}/matchups/${week}`);
                            if (!mResp.ok) break; // no more matchup data
                            const matchups = await mResp.json();
                            if (!Array.isArray(matchups) || matchups.length === 0) break;

                            // Compute median points across all rosters this week for lucky/unlucky classification
                            const allPoints = matchups.map(e => Number(e.points ?? e.fpts ?? 0)).filter(v => !isNaN(v));
                            let medianPoint = 0;
                            if (allPoints.length > 0) {
                                allPoints.sort((a, b) => a - b);
                                const mid = Math.floor(allPoints.length / 2);
                                medianPoint = (allPoints.length % 2 === 1) ? allPoints[mid] : ((allPoints[mid - 1] + allPoints[mid]) / 2);
                            }

                            // For each matchup, compare points and award expected win to higher score
                            matchups.forEach(mu => {
                                if (!mu || typeof mu.roster_id === 'undefined') return;
                                // Sleeper returns an array of matchup objects where each has roster_id and points
                                // But depending on endpoint, matchups may be an array of rosters for that week.
                                // We'll handle arrays of roster objects (common) where each element has "roster_id" and "points".
                                if (Array.isArray(mu)) return; // defensive: skip nested arrays
                            });

                            // The /matchups/{week} endpoint returns an array of roster objects (each roster entry for that week),
                            // but the pairing isn't explicit here. We'll instead use /league/{leagueId}/matchups/{week} which returns
                            // an array of matchup objects; ensure we treat each object that contains multiple roster entries.
                            // To be robust, if matchups is an array of objects where each object has a "players" or "rosters" field,
                            // attempt to normalize. Otherwise, if entries have "roster_id" and "points", group by matchupId.

                            // Build grouping: if objects have 'matchup_id' or 'matchup_id' use that, otherwise try 'matchup' or pair by order.
                            const groups = {};
                            matchups.forEach(entry => {
                                const mid = entry.matchup_id ?? entry.matchup ?? entry.week ?? entry.matchupId ?? 'm_' + (entry.roster_id ?? Math.random());
                                if (!groups[mid]) groups[mid] = [];
                                groups[mid].push(entry);
                            });

                            Object.values(groups).forEach(group => {
                                if (group.length < 2) return; // need opponent to compare
                                // For each roster in group, compare to opponents
                                group.forEach(playerEntry => {
                                    const rid = playerEntry.roster_id;
                                    const pts = Number(playerEntry.points ?? playerEntry.fpts ?? 0);
                                    if (rid == null) return;
                                    const idx = rosterIndex[rid];
                                    if (typeof idx === 'undefined') return; // roster not in this league's roster list
                                    stats[idx].gamesCounted++;
                                    // Compare against other players in same group
                                    let winsAgainst = 0;
                                    group.forEach(other => {
                                        if (other === playerEntry) return;
                                        const otherPts = Number(other.points ?? other.fpts ?? 0);
                                        if (pts > otherPts) winsAgainst += 1;
                                    });
                                    const fractional = winsAgainst / (group.length - 1);
                                    stats[idx].expectedWins += fractional;
                                    // Determine whether this roster "won" or "lost" the matchup (beat majority of opponents)
                                    const won = winsAgainst > ((group.length - 1) / 2);
                                    const lost = winsAgainst < ((group.length - 1) / 2);
                                    if (won && pts < medianPoint) {
                                        stats[idx].luckyWins += 1;
                                    }
                                    if (lost && pts > medianPoint) {
                                        stats[idx].unluckyLosses += 1;
                                    }
                                });
                            });
                        } catch (e) {
                            console.warn('Week fetch error', week, e);
                            break;
                        }
                    }

                    // Now compute luck = (+1 per lucky win) + (-1 per unlucky loss)
                    stats.forEach(s => {
                        s.luck = (s.luckyWins ?? 0) - (s.unluckyLosses ?? 0);
                    });

                    // Prepare summary: top 3 lucky and top 3 unlucky
                    const summary = [...stats];
                    summary.sort((a, b) => b.luck - a.luck);
                    const topLucky = summary.slice(0, 3);
                    const topUnlucky = summary.slice(-3).reverse();

                    // Build luck block content
                    let summaryHTML = `<div class="stats-highlight center"><h4>Luck Summary</h4><div style="display:flex;gap:20px;flex-wrap:wrap;">`;
                    summaryHTML += `<div><strong>Top Lucky</strong><ol>`;
                    topLucky.forEach(t => { summaryHTML += `<li>${t.owner} (${t.luck>=0? '+'+t.luck: t.luck})</li>` });
                    summaryHTML += `</ol></div>`;
                    summaryHTML += `<div><strong>Top Unlucky</strong><ol>`;
                    topUnlucky.forEach(t => { summaryHTML += `<li>${t.owner} (${t.luck>=0? '+'+t.luck: t.luck})</li>` });
                    summaryHTML += `</ol></div>`;
                    summaryHTML += `</div></div>`;

                    // Generate table HTML (no change to content)

                    // Sort standings by wins descending
                    stats.sort((a, b) => b.wins - a.wins || b.points - a.points);

                    // Generate standings table with Expected Wins and Luck columns
                    let tableHTML = `
                        <h3>Standings (with Luck):</h3>
                        <table border="1">
                            <thead>
                                <tr>
                                    <th onclick="sortTable(0)">Owner</th>
                                    <th onclick="sortTable(1)">Wins</th>
                                    <th onclick="sortTable(2)">Losses</th>
                                    <th onclick="sortTable(3)">Points</th>
                            <th onclick="sortTable(4,this)">Luck</th>
                            <th onclick="sortTable(5,this)">Lucky Wins</th>
                            <th onclick="sortTable(6,this)">Unlucky Losses</th>
                                </tr>
                            </thead>
                            <tbody>
                    `;

                    stats.forEach(s => {
                        const wins = s.wins ?? 0;
                        const losses = s.losses ?? 0;
                        const points = s.points ?? 0;
                        const luck = Number(s.luck ?? 0);
                        const luckyWins = s.luckyWins ?? 0;
                        const unluckyLosses = s.unluckyLosses ?? 0;
                        tableHTML += `
                            <tr>
                                <td>${s.owner}</td>
                                <td>${wins}</td>
                                <td>${losses}</td>
                                <td>${points}</td>
                                <td style="color:${luck>0? 'green': (luck<0? 'red':'black')}">${luck>0? '+'+luck: luck}</td>
                                <td>${luckyWins}</td>
                                <td>${unluckyLosses}</td>
                            </tr>
                        `;
                    });

                    tableHTML += `</tbody></table>`;

                    // Prepare content for luck block but do not render immediately â€” provide a renderer
                    window.__luckBlockContent = { summaryHTML, tableHTML };
                    function renderLuckBlock() {
                        const blocksDiv = document.getElementById('blocks');
                        const luckBlock = document.createElement('div');
                        luckBlock.className = 'block';
                        luckBlock.id = 'luck-block';
                        luckBlock.innerHTML = `<h3>Luck</h3>` + window.__luckBlockContent.summaryHTML + window.__luckBlockContent.tableHTML;
                        const existing = document.getElementById('luck-block');
                        if (existing) blocksDiv.replaceChild(luckBlock, existing); else blocksDiv.appendChild(luckBlock);
                    }
                    function removeLuckBlock() {
                        const existing = document.getElementById('luck-block');
                        if (existing) existing.remove();
                    }

                    // --- Power Rankings content: compute PPG and ranks ---
                    const power = stats.map(s => {
                        const wins = s.wins ?? 0;
                        const losses = s.losses ?? 0;
                        const matches = Number(wins) + Number(losses);
                        return {
                            roster_id: s.roster_id,
                            owner: s.owner,
                            points: s.points ?? 0,
                            matches: matches,
                            wins: wins,
                            losses: losses,
                            ppg: (matches > 0) ? (s.points / matches) : 0
                        };
                    });
                    power.sort((a, b) => b.ppg - a.ppg || b.points - a.points);
                    // assign rank after sorting: 1 = highest PPG
                    power.forEach((p, i) => { p.rank = i + 1; });
                    let powerSummary = `<div class="stats-highlight"><h4>Power Rankings Top</h4><ol>`;
                    power.slice(0,3).forEach(p => { powerSummary += `<li>${p.owner} â€” ${p.ppg.toFixed(1)} PPG</li>`; });
                    powerSummary += `</ol></div>`;

                    let powerTable = `
                        <h3>Power Rankings (by PPG)</h3>
                        <table border="1">
                            <thead>
                                <tr>
                                    <th onclick="sortTable(0,this)">Rank</th>
                                    <th onclick="sortTable(1,this)">Owner</th>
                                    <th onclick="sortTable(2,this)">PPG</th>
                                    <th onclick="sortTable(3,this)">Total Points</th>
                                    <th onclick="sortTable(4,this)">Matches</th>
                                    <th onclick="sortTable(5,this)">Wins</th>
                                    <th onclick="sortTable(6,this)">Losses</th>
                                </tr>
                            </thead>
                            <tbody>
                    `;
                    power.forEach(p => {
                        powerTable += `
                            <tr>
                                <td>${p.rank}</td>
                                <td>${p.owner}</td>
                                <td>${p.ppg.toFixed(1)}</td>
                                <td>${p.points}</td>
                                <td>${p.matches}</td>
                                <td>${p.wins}</td>
                                <td>${p.losses}</td>
                            </tr>
                        `;
                    });
                    powerTable += `</tbody></table>`;

                    window.__powerBlockContent = { powerSummary, powerTable };
                    function renderPowerBlock() {
                        const blocksDiv = document.getElementById('blocks');
                        const powerBlock = document.createElement('div');
                        powerBlock.className = 'block';
                        powerBlock.id = 'power-block';
                        powerBlock.innerHTML = `<h3>Power Rankings</h3>` + window.__powerBlockContent.powerSummary + window.__powerBlockContent.powerTable;
                        const existing = document.getElementById('power-block');
                        if (existing) blocksDiv.replaceChild(powerBlock, existing); else blocksDiv.appendChild(powerBlock);
                    }
                    function removePowerBlock() {
                        const existing = document.getElementById('power-block');
                        if (existing) existing.remove();
                    }
                } else {
                    leagueInfoDiv.innerHTML += '<p>No rosters found for this league.</p>';
                }
            } catch (error) {
                leagueInfoDiv.innerHTML = `<p>Error: ${error.message}</p>`;
                console.error('Error:', error);
            }
        }

        // Add sorting functionality
        function sortTable(columnIndex, headerEl) {
            // Determine target table body: if headerEl provided, use its table; otherwise fallback
            let tbody;
            if (headerEl && headerEl.closest) {
                const tableEl = headerEl.closest('table');
                if (tableEl) tbody = tableEl.querySelector('tbody');
            }
            if (!tbody) tbody = document.querySelector('#league-info table tbody');
            if (!tbody) return;

            const rows = Array.from(tbody.rows);
            if (rows.length < 2) return; // nothing to sort

            // Determine sort direction based on first two rows (text comparison)
            const aText = rows[0].cells[columnIndex]?.innerText ?? '';
            const bText = rows[1].cells[columnIndex]?.innerText ?? '';
            const ascending = aText > bText;

            // Sort rows using numeric-aware localeCompare
            rows.sort((a, b) => {
                const cellA = a.cells[columnIndex]?.innerText ?? '';
                const cellB = b.cells[columnIndex]?.innerText ?? '';
                return ascending
                    ? cellA.localeCompare(cellB, undefined, { numeric: true })
                    : cellB.localeCompare(cellA, undefined, { numeric: true });
            });

            // Rebuild table body
            tbody.innerHTML = '';
            rows.forEach(row => tbody.appendChild(row));
        }


        // Function to handle league selection
        function selectLeague(leagueId, leagueName) {
            console.log(`Selected League ID: ${leagueId}, Name: ${leagueName}`);
            // Additional logic for the selected league can go here
            getLeague(leagueId)
        }
        function escapeHTML(str) {
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }
    </script>
    
    <div class="copyright">
        <p>Copyright Â© 2025 Kyle Illenden, Anthony Illenden. Released under MIT License.</p>
        <p>LaPorta Potty Platoon</p>
    </div>
</body>
</html>

